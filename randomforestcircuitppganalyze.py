# -*- coding: utf-8 -*-
"""RANDOMForestCircuitPpganalyze.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CNx3bZ3WkNtIP4zQaD8zhsxB01epg1dR
"""

'''
Jeremy Yu
jsy201910@gmail.com
Revision History
Date Changes Programmer
---------------------------------------------------
7/15/2025 Original  Jeremy Yu
7/16/2025 analysis of data  Jeremy Yu
7/17/2025 NaN initialization  Jeremy Yu
7/18/2025 Input of Logs Jeremy Yu
7/19/2025 Graphing of PPG Jeremy Yu
7/20/2025 Graphing of EDA Jeremy Yu
7/21/2025 Shaded regions  Jeremy Yu
7/22/2025 Time aligning labeling and plots  Jeremy Yu
7/23/2025 Signal Preprocessing  Jeremy Yu
7/24/2025 Bandpass refiltering  Jeremy Yu
7/25/2025 Rework of all Plots Jeremy Yu
'''
!pip install heartpy #10 Seconds
import heartpy as hp
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from imblearn.over_sampling import RandomOverSampler
from sklearn.preprocessing import StandardScaler
import copy
import seaborn as sns
import tensorflow as tf
from sklearn.linear_model import LinearRegression
from tqdm import tqdm
import warnings

# Load data
df = pd.read_csv('dac_adc_recording_1st.csv.csv')
signal = df['ir'].values
df1 = pd.read_csv("dac_adc_recording_1st.csv.csv")
df2 = pd.read_csv("dac_adc_recording_2nd.csv.csv")
df1['trueElapsedSeconds'] = np.nan  # Initialize with NaN
df1['trueElapsedSeconds'] = (df1['elapsed_seconds']-343.955).ffill()
time = df1['trueElapsedSeconds'].values

# Define segments1, accurately counted elapsed time
segments1 = [
    (343.955-343.955, 526.98-343.955, 'Relax 1', 'lightblue'),
    (526.98-343.955, 732.505-343.955, 'Stroop Test', 'lightcoral'),
    (732.505-343.955, 927.984-343.955, 'Math Test', 'orange'),
    (927.984-343.955, 1120.695-343.955, 'Relax 2', 'lightblue'),
]

# Normalize signal (0 to 1)
normalized = (signal - np.min(signal)) / (np.max(signal) - np.min(signal))

# Plot with background labels
plt.figure(figsize=(12, 4))
plt.plot(time, normalized, label='Normalized ppg', linewidth=0.8)

# Define segments
segments = [
    (343.955, 526.98, 'Relax 1', 'lightblue'),
    (526.98, 732.505, 'Stroop Test', 'lightcoral'),
    (732.505, 927.984, 'Math Test', 'orange'),
    (927.984, 1120.695, 'Relax 2', 'lightblue'),
]


# Highlight background regions
for start, end, label, color in segments1:
    plt.axvspan(start, end, color=color, alpha=0.3, label=label)
plt.xlabel('Elapsed Time (s)', fontsize=25)
plt.ylabel('Normalized Signal', fontsize=25)
plt.title('PPG Signal with Event Segments', fontsize=25)
plt.legend()
plt.tight_layout()
plt.savefig('plot1.jpg', format='jpg', dpi=300)
plt.show()


signal = df['eda'].values

# Normalize signal (0 to 1)
normalized = (signal - np.min(signal)) / (np.max(signal) - np.min(signal))

plt.figure(figsize=(12, 4))
plt.plot(time, normalized, label='Normalized eda', linewidth=0.8)

for start, end, label, color in segments1:
    plt.axvspan(start, end, color=color, alpha=0.3, label=label)

plt.xlabel('Elapsed Time (s)', fontsize=25)
plt.ylabel('Normalized Signal', fontsize=25)
plt.title('EDA Signal with Event Segments', fontsize=25)
plt.legend()
plt.tight_layout()
plt.savefig('plot2.jpg', format='jpg', dpi=300)
plt.show()

#######################################################################

#print(max(df1['ir'])) #127390
#print(min(df1['ir'])) #119271
data1 = df1['ir'].values
data2 = df2['ir'].values


normalized_data1 = (df1['ir'] - min(df1['ir'])) / (max(df1['ir']) - min(df1['ir']))
print(normalized_data1)

normalized_data2 = (df2['ir'] - min(df2['ir'])) / (max(df2['ir']) - min(df2['ir']))
print(normalized_data2)
#### 5.60 Hz

start_time = df1['elapsed_seconds'].iloc[0]
end_time = df1['elapsed_seconds'].iloc[-1]
elapsed_time = end_time - start_time  # in seconds (assuming already in seconds, not ms)

#### 7.35 Hz
start_time = df2['elapsed_seconds'].iloc[0]
end_time = df2['elapsed_seconds'].iloc[-1]
elapsed_time = end_time - start_time  # in seconds (assuming already in seconds, not ms)

# Confirm it's in seconds; if in ms, divide by 1000:
if elapsed_time > 1000:
    elapsed_time = elapsed_time / 1000  # convert ms to seconds



# Compute sampling rate safely
if elapsed_time == 0:
    raise ValueError("Elapsed time is zero. Check 'elapsed_seconds' values.")
sample_rate = len(df1) / elapsed_time
print(sample_rate)
filtered_ppg = hp.filter_signal(df1.iloc[:, 0],
                                cutoff=[0.8, 2.5],
                                filtertype='bandpass',
                                sample_rate=sample_rate,
                                order=1,
                                return_top=False)
start_sec = 180
end_sec = 190
start_idx = int(start_sec * sample_rate)
end_idx = int(end_sec * sample_rate)

wd, m = hp.process(filtered_ppg, sample_rate=sample_rate)
plt.figure(figsize=(12, 6))

hp.plotter(wd, m)

# Number of samples for that duration

# Slice the first 10 seconds of filtered_ppg
subset_ppg = filtered_ppg[start_idx:end_idx]


# Re-process the sliced segment
wd, m = hp.process(subset_ppg, sample_rate=sample_rate)

# Plot
plt.figure(figsize=(12, 6))
hp.plotter(wd, m)
plt.savefig('plot3.jpg', format='jpg', dpi=300)
plt.show()
plt.figure(figsize=(12,4))
plot_object=hp.plotter(wd, m, title='Filtered Heart Beat Detection on Noisy Signal', show=False)
#plot_object.savefig('Filtered_HB_detetcion_Samiha.jpg') #saves the plot as JPEG image.
####################
df1['Average_Heart_Rate'] = np.nan  # Initialize with NaN
window_duration = 5  # seconds
start_idx = 0
n = len(df1)
last_bpm = None
min_samples = 5

HR = [ ]

warnings.filterwarnings('ignore', category=RuntimeWarning)
df1['Average_Heart_Rate'] = df1['Average_Heart_Rate'].ffill()

while start_idx < n:
    start_time = df1['elapsed_seconds'].iloc[start_idx]
    end_idx = start_idx
    while end_idx < n and df1['elapsed_seconds'].iloc[end_idx] - start_time < window_duration:
        end_idx += 1

    segment = filtered_ppg[start_idx:end_idx]

    if len(segment) < min_samples:
        # Too short, reuse last bpm
        if last_bpm is not None:
            df1.loc[start_idx:end_idx, 'Average_Heart_Rate'] = last_bpm
        start_idx = end_idx
        continue

    try:
        wd, m = hp.process(segment, sample_rate=sample_rate)
        bpm = m['bpm']
        if not np.isnan(bpm):  # Check if bpm is valid
            last_bpm = bpm
            laster_bpm = bpm
        df1.loc[start_idx:end_idx, 'Average_Heart_Rate'] = last_bpm
        print(f"Window {start_idx}-{end_idx}: HR={bpm:.2f}, RMSSD={m['rmssd']:.2f}")
        HR.append(bpm)
    except Exception as e:
        # On failure, reuse last valid bpm if available
        if last_bpm is not None:
            df1.loc[start_idx:end_idx, 'Average_Heart_Rate'] = last_bpm
            HR.append(laster_bpm)
        else:
            df1.loc[start_idx:end_idx, 'Average_Heart_Rate'] = np.nan
            HR.append(laster_bpm)

    start_idx = end_idx
segments1 = [
    (343.955-343.955, 526.98-343.955, 'Relax 1', 'lightblue'),
    (526.98-343.955, 732.505-343.955, 'Stroop Test', 'lightcoral'),
    (732.505-343.955, 927.984-343.955, 'Math Test', 'orange'),
    (927.984-343.955, 1120.695-343.955, 'Relax 2', 'lightblue'),
]
#343.955

time_array = np.arange(n) / 9.637665716093109

plt.figure(figsize=(12, 6))
plt.plot(df1['trueElapsedSeconds'],df1['Average_Heart_Rate'] )
for start, end, label, color in segments1:
    plt.axvspan(start, end, color=color, alpha=0.3, label=label)
plt.legend()
plt.title("Average Heart Rate over Time", fontsize=25)
plt.xlabel("Time (seconds)", fontsize=25)
plt.ylabel("Heart Rate (BPM)", fontsize=25)

plt.ylim(min(df1['Average_Heart_Rate'])-20, max(df1['Average_Heart_Rate'])+20)
plt.grid(True)
plt.tight_layout()
plt.savefig('plot4.jpg', format='jpg', dpi=300)
plt.show()
HR_cleaned = [float(x) for x in HR if not np.isnan(x)]
print(HR_cleaned)
print("HR above here")

HR_Min = min(HR_cleaned)
HR_Max = max(HR_cleaned)
HR_Q1 = np.percentile(HR_cleaned, 25)
HR_Q3 = np.percentile(HR_cleaned, 75)
print(HR_Min, HR_Max, HR_Q1, HR_Q3)
########################################################
########333333333333333333333333333333333
print(len(HR_cleaned))

i1 = 0
i2 = 31
i3 = 65
i4 = 99
i5 = 131  # end

Relax1 = HR_cleaned[i1:i2]
Stroop = HR_cleaned[i2:i3]
MathTest = HR_cleaned[i3:i4]
Relax2 = HR_cleaned[i4:i5]

HR_df = pd.DataFrame({
    'Heart Rate': Relax1 + Stroop + MathTest + Relax2,
    'Condition': ['Relax 1'] * len(Relax1) +
                 ['Stroop'] * len(Stroop) +
                 ['Math Test'] * len(MathTest) +
                 ['Relax 2'] * len(Relax2)
})

# Plot

sns.boxplot(x='Condition', y='Heart Rate', data=HR_df, palette='Set2')
plt.title('Modified Box Plot of Heart Rates', fontsize=25)
plt.ylabel('Average Heart Rate (BPM)', fontsize=25)
plt.savefig('plot5.jpg', format='jpg', dpi=300)
plt.show()
#######################
df1['RMSSD'] = np.nan  # Initialize
window_duration = 21  # seconds
start_idx = 0
n = len(df1)
last_rmssd = None
min_samples = 5

while start_idx < n:
    start_time = df1['elapsed_seconds'].iloc[start_idx]
    end_idx = start_idx
    while end_idx < n and df1['elapsed_seconds'].iloc[end_idx] - start_time < window_duration:
        end_idx += 1

    segment = filtered_ppg[start_idx:end_idx]

    if len(segment) < min_samples or np.all(segment == 0):
        if last_rmssd is not None:
            df1.loc[start_idx:end_idx, 'RMSSD'] = last_rmssd
        start_idx = end_idx
        continue

    try:
        wd, m = hp.process(segment, sample_rate=sample_rate)
        RMSSD = m['rmssd']
        if not np.isnan(RMSSD):
            last_rmssd = RMSSD
        df1.loc[start_idx:end_idx, 'RMSSD'] = last_rmssd
    except Exception as e:
        df1.loc[start_idx:end_idx, 'RMSSD'] = last_rmssd if last_rmssd is not None else np.nan

    start_idx = end_idx

# Plotting
plt.figure(figsize=(12, 6))
plt.plot(df1['trueElapsedSeconds'],df1['RMSSD'] )
for start, end, label, color in segments1:
    plt.axvspan(start, end, color=color, alpha=0.3, label=label)
plt.title("Average RMSSD (Heart Rate Variability) Over Time", fontsize=25)
plt.xlabel("Time (seconds)", fontsize=25)
plt.ylabel("RMSSD (ms)", fontsize=25)
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.savefig('plot6.jpg', format='jpg', dpi=300)
plt.show()

##########
df1['ibi'] = np.nan  # Initialize
window_duration = 5  # seconds
start_idx = 0
n = len(df1)
last_ibi = None
min_samples = 3

while start_idx < n:
    start_time = df1['elapsed_seconds'].iloc[start_idx]
    end_idx = start_idx
    while end_idx < n and df1['elapsed_seconds'].iloc[end_idx] - start_time < window_duration:
        end_idx += 1

    segment = filtered_ppg[start_idx:end_idx]

    if len(segment) < min_samples or np.all(segment == 0):
        if last_ibi is not None:
            df1.loc[start_idx:end_idx, 'ibi'] = last_ibi
        start_idx = end_idx
        continue

    try:
        wd, m = hp.process(segment, sample_rate=sample_rate)
        ibi = m['ibi']
        if not np.isnan(ibi):
            last_ibi = ibi
        df1.loc[start_idx:end_idx, 'ibi'] = last_ibi
    except Exception as e:
        df1.loc[start_idx:end_idx, 'ibi'] = last_ibi if last_ibi is not None else np.nan

    start_idx = end_idx

# Plotting
plt.figure(figsize=(12, 6))
plt.plot(df1['trueElapsedSeconds'],df1['ibi'] )
for start, end, label, color in segments1:
    plt.axvspan(start, end, color=color, alpha=0.3, label=label)
plt.legend()
plt.title("Average ibi Over Time", fontsize=25)
plt.xlabel("Time (seconds)", fontsize=25)
plt.ylabel("ibi (ms)", fontsize=25)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)

plt.grid(True)
plt.legend()
plt.ylim(min(df1['ibi'])-20, max(df1['ibi'])+20)
plt.tight_layout()
plt.savefig('plot7.jpg', format='jpg', dpi=300)
plt.show()

#data values
#print(max(df2['ir'])) #122093
#print(min(df2['ir'])) #100375
#526.98, 732.505 , 927.984, 1120.695